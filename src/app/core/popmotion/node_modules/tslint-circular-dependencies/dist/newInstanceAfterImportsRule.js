"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Lint = require("tslint");
const ts = require("typescript");
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithWalker(new NewInstanceAtEofWalker(sourceFile, this.getOptions()));
    }
}
Rule.metadata = {
    ruleName: "new-instance-after-imports",
    description: Lint.Utils.dedent `
                          Move creation of new instances to the bottom of the
                          file, after all classes have been declared and
                          imported.

                          This rule will identify \`new\` calls directly on
                          SourceFile level and will leave other \`new\` calls
                          untouched, e.g.

                           \`new\` calls inside blocks or as parts of other
                           expressions will remain unchanged.`,
    hasFix: true,
    optionsDescription: "no options",
    options: {},
    type: "functionality",
    typescriptOnly: false,
};
Rule.NEW_AT_EOF = "`new` should be moved to end of file";
exports.Rule = Rule;
class NewInstanceAtEofWalker extends Lint.RuleWalker {
    constructor() {
        super(...arguments);
        this.classDeclarations = new Map();
        this.rootLevelNewExpressions = [];
    }
    visitSourceFile(node) {
        super.visitSourceFile(node);
        if (!this.lastImportDeclaration) {
            return;
        }
        const classNames = Array.from(this.classDeclarations.keys());
        this.rootLevelNewExpressions.forEach((newExpr) => {
            const name = newExpr.expression.getText();
            if (classNames.includes(name) && newExpr.getEnd() < this.lastImportDeclaration.getStart()) {
                this.addFailureAtNode(newExpr, Rule.NEW_AT_EOF, [
                    Lint.Replacement.replaceNode(newExpr.parent, ''),
                    Lint.Replacement.appendText(this.lastImportDeclaration.getEnd(), newExpr.parent.getFullText())
                ]);
            }
        });
    }
    visitClassDeclaration(node) {
        const name = node.name && node.name.getText();
        if (name) {
            this.classDeclarations.set(name, node);
        }
        super.visitClassDeclaration(node);
    }
    visitNewExpression(node) {
        if (node.parent.parent.kind === ts.SyntaxKind.SourceFile) {
            this.rootLevelNewExpressions.push(node);
        }
        super.visitNewExpression(node);
    }
    visitImportDeclaration(node) {
        this.lastImportDeclaration = node;
        super.visitImportDeclaration(node);
    }
}
