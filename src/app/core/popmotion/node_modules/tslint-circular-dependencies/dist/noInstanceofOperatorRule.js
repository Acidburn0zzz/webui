"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Lint = require("tslint");
const ts = require("typescript");
const debug = require('debug')('tslint-no-instanceof-operator');
debug('yo');
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithWalker(new NoInstanceOfOperatorWalker(sourceFile, this.getOptions()));
    }
}
Rule.metadata = {
    ruleName: "no-instanceof-operator",
    description: "Replace `instanceof` with checks for `constructor.name`.",
    hasFix: true,
    optionsDescription: "no options",
    options: {},
    type: "functionality",
    typescriptOnly: false,
};
Rule.REPLACE_INSTANCEOF = "`instanceof` operator should be replaced with ";
exports.Rule = Rule;
class NoInstanceOfOperatorWalker extends Lint.RuleWalker {
    constructor() {
        super(...arguments);
        this.instanceOfClassWasImported = false;
        this.needInstanceOfClass = false;
    }
    visitSourceFile(node) {
        this.needInstanceOfClass = this.instanceOfClassWasImported = false;
        super.visitSourceFile(node);
        if (this.needInstanceOfClass && !this.instanceOfClassWasImported) {
            this.addFailureAtNode(node, "file should import `instanceOfClass` from createjs-utilities", Lint.Replacement.appendText(node.getFullWidth() + 1, '\nimport { instanceOfClass } from "@goodgamestudios/createjs-utilities";\n'));
        }
    }
    visitBinaryExpression(node) {
        if (node.operatorToken.kind !== ts.SyntaxKind.InstanceOfKeyword) {
            return super.visitBinaryExpression(node);
        }
        if (node.right.kind !== ts.SyntaxKind.Identifier &&
            node.right.kind !== ts.SyntaxKind.PropertyAccessExpression &&
            node.right.kind !== ts.SyntaxKind.ElementAccessExpression) {
            return super.visitBinaryExpression(node);
        }
        const getReplacementText = () => {
            const rightText = node.right.getText();
            const leftText = node.left.getText();
            if (node.right.kind === ts.SyntaxKind.Identifier) {
                switch (rightText) {
                    case 'Boolean': return `(typeof ${leftText} === 'boolean')`;
                    case 'String': return `(typeof ${leftText} === 'string')`;
                    case 'Number': return `(typeof ${leftText} === 'number')`;
                }
            }
            this.needInstanceOfClass = true;
            return `instanceOfClass(${leftText}, "${rightText.split('.').pop()}")`;
            ;
        };
        const replaceWith = getReplacementText();
        this.addFailureAtNode(node.operatorToken, `${Rule.REPLACE_INSTANCEOF} \`${replaceWith}\``, Lint.Replacement.replaceNode(node, replaceWith));
        return super.visitBinaryExpression(node);
    }
    visitNamedImports(node) {
        if (this.instanceOfClassWasImported)
            return;
        this.instanceOfClassWasImported = !!node.elements.find(namedImport => {
            return namedImport.name.text === 'instanceOfClass';
        });
    }
}
