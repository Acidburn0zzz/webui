"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const Lint = require("tslint");
const ts = require("typescript");
const debug = require('debug')('imports-after-export');
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithWalker(new ImportsAfterExportsWalker(sourceFile, this.getOptions()));
    }
}
Rule.metadata = {
    ruleName: "imports-after-export",
    description: Lint.Utils.dedent `
                          Move all \`import\` statements that are not superclasses
                          below the last \`export\` statement to enable circular
                          imports.`,
    hasFix: true,
    optionsDescription: "no options",
    options: {},
    type: "functionality",
    typescriptOnly: false,
};
Rule.IMPORTS_AFTER_EXPORTS = "`import` should be moved after the last `export`";
exports.Rule = Rule;
class ImportsAfterExportsWalker extends Lint.RuleWalker {
    constructor() {
        super(...arguments);
        this.importedNames = new Map();
        this.inheritedNames = new Map();
        this.fix = [];
    }
    visitSourceFile(node) {
        super.visitSourceFile(node);
        if (!this.lastExportStatement) {
            debug("No lastExportStatement");
            return;
        }
        const inheritImportModuleNames = Array
            .from(this.inheritedNames.keys())
            .map((inheritIdentifier) => {
            if (!this.importedNames.get(inheritIdentifier)) {
                debug(`No \`import\` found for ${inheritIdentifier}`);
                return null;
            }
            return this.importedNames.get(inheritIdentifier).moduleSpecifier.getText();
        })
            .filter(identifier => identifier);
        const importModuleNames = new Set();
        const uniqueNodes = new Set();
        Array
            .from(this.importedNames.values())
            .filter((importNode) => {
            const moduleName = importNode.moduleSpecifier.getText();
            importModuleNames.add(moduleName);
            return true;
        })
            .filter((importNode) => {
            return !inheritImportModuleNames.includes(importNode.moduleSpecifier.getText());
        })
            .filter((importNode) => {
            return importNode.getStart() < this.lastExportStatement.getStart();
        })
            .filter((importNode) => {
            if (uniqueNodes.has(importNode))
                return false;
            uniqueNodes.add(importNode);
            return true;
        })
            .forEach((importNode) => {
            this.addFailureAtNode(importNode, Rule.IMPORTS_AFTER_EXPORTS, [
                Lint.Replacement.replaceNode(importNode, ''),
                Lint.Replacement.appendText(this.lastExportStatement.getEnd(), "\n" + importNode.getText())
            ]);
        });
    }
    visitImportDeclaration(node) {
        if (!ts.isStringLiteral(node.moduleSpecifier)) {
            return;
        }
        switch (_.get(node, "importClause.namedBindings.kind")) {
            case ts.SyntaxKind.NamespaceImport: {
                const namespaceImport = node.importClause.namedBindings;
                this.importedNames.set(namespaceImport.name.text, node);
                break;
            }
            case ts.SyntaxKind.NamedImports: {
                const namedImports = node.importClause.namedBindings;
                namedImports.elements.forEach((element) => {
                    this.importedNames.set(element.name.text, node);
                });
                break;
            }
            default:
                debug(node);
                return;
        }
        super.visitImportDeclaration(node);
    }
    visitClassDeclaration(node) {
        this.rememberExportModifier(node);
        if (node.heritageClauses) {
            node.heritageClauses
                .filter((heritageClause) => heritageClause.token === ts.SyntaxKind.ExtendsKeyword)
                .forEach((heritageClause) => {
                heritageClause.types.forEach((aType) => {
                    this.inheritedNames.set(aType.getText(), node);
                });
            });
        }
        super.visitClassDeclaration(node);
    }
    visitExportAssignment(node) {
        this.rememberExportModifier(node);
        super.visitExportAssignment(node);
    }
    visitInterfaceDeclaration(node) {
        this.rememberExportModifier(node);
        super.visitInterfaceDeclaration(node);
    }
    rememberExportModifier(node) {
        if (_.some(node.modifiers, { kind: ts.SyntaxKind.ExportKeyword })) {
            this.lastExportStatement = node;
        }
    }
}
