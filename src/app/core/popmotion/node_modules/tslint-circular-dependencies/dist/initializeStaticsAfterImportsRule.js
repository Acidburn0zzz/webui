"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const Lint = require("tslint");
const ts = require("typescript");
const debug = require('debug')('initialize-statics-after-imports');
class Rule extends Lint.Rules.AbstractRule {
    apply(sourceFile) {
        return this.applyWithWalker(new InitzializeStaticsAfterImportsWalker(sourceFile, this.getOptions()));
    }
}
Rule.metadata = {
    ruleName: "initialize-statics-after-imports",
    description: Lint.Utils.dedent `
                          Initialize all \`static\` class members after imports`,
    hasFix: true,
    optionsDescription: "no options",
    options: {},
    type: "functionality",
    typescriptOnly: true,
};
Rule.STATICS_AFTER_IMPORTS = "`static` member should be moved after the last `import`";
Rule.CLASS_SHOULD_INITIALIZE_STATICS_IN_FUNCTION = "This `Class` should initialize `static` members in a static function";
Rule.FILE_SHOULD_CALL_STATIC_INITIALIZATION_FUNCTION = "This file should call a static initialization function";
exports.Rule = Rule;
class InitzializeStaticsAfterImportsWalker extends Lint.RuleWalker {
    constructor() {
        super(...arguments);
        this.staticInitializers = [];
    }
    visitSourceFile(node) {
        this.staticInitializers = [];
        super.visitSourceFile(node);
        if (!this.lastImportStatement) {
            return;
        }
        this.orderStaticInitializationMethodCalls();
    }
    visitImportDeclaration(node) {
        this.lastImportStatement = node;
        super.visitImportDeclaration(node);
    }
    visitClassDeclaration(node) {
        this.staticInitializers = [];
        this.staticInitFunction = null;
        super.visitClassDeclaration(node);
        if (!this.staticInitializers.length) {
            return;
        }
        const className = node.name.getText();
        const allInitializationStatements = this.staticInitializers
            .filter((staticDeclaration) => {
            const initializer = staticDeclaration.initializer;
            if (!initializer) {
                return false;
            }
            debug({
                isArrayLiteralExpression: ts.isArrayLiteralExpression(initializer),
                isLiteralExpression: ts.isLiteralExpression(initializer),
                kind: ts.SyntaxKind[staticDeclaration.initializer.kind],
                text: initializer.getText(),
            });
            return !ts.isLiteralTypeNode(initializer)
                && !ts.isPrefixUnaryExpression(initializer);
        })
            .map((staticDeclaration) => {
            return `\t\t${className}.${staticDeclaration.name.getText()}=${staticDeclaration.initializer.getText()};`;
        })
            .join("\n");
        this.staticInitializers.forEach((staticDeclaration) => {
            this.addFailureAtNode(staticDeclaration, Rule.STATICS_AFTER_IMPORTS, Lint.Replacement.replaceFromTo(staticDeclaration.getStart(), staticDeclaration.getEnd(), staticDeclaration.getText().replace(/\s*=(?:.|\s)+/, ";")));
        });
        if (this.staticInitFunction) {
            const { index } = /(\s*)};?\s*$/.exec(this.staticInitFunction.body.getText());
            this.addFailureAtNode(node, Rule.CLASS_SHOULD_INITIALIZE_STATICS_IN_FUNCTION, Lint.Replacement.appendText(this.staticInitFunction.body.getStart() + index, '\n' + allInitializationStatements));
        }
        else {
            const fnText = `\n\tpublic static ${InitzializeStaticsAfterImportsWalker.METHOD_NAME}() {\n${allInitializationStatements}\n\t}\n`;
            this.addFailureAtNode(node, Rule.CLASS_SHOULD_INITIALIZE_STATICS_IN_FUNCTION, Lint.Replacement.appendText(node.getEnd() - 1, fnText));
            const callInitializer = `${node.name.getText()}.${InitzializeStaticsAfterImportsWalker.METHOD_NAME}();\n`;
            this.addFailureAtNode(this.getSourceFile(), Rule.FILE_SHOULD_CALL_STATIC_INITIALIZATION_FUNCTION, Lint.Replacement.appendText(this.getSourceFile().getEnd(), callInitializer));
        }
        this.staticInitializers = [];
        this.staticInitFunction = null;
    }
    visitMethodDeclaration(node) {
        if (node.name.getText() === InitzializeStaticsAfterImportsWalker.METHOD_NAME) {
            this.staticInitFunction = node;
        }
    }
    visitPropertyDeclaration(node) {
        if (!node.initializer) {
            return super.visitPropertyDeclaration(node);
        }
        const isLiteral = ts.isPrefixUnaryExpression(node.initializer)
            || node.initializer.kind === ts.SyntaxKind.FalseKeyword
            || node.initializer.kind === ts.SyntaxKind.TrueKeyword;
        if (!isLiteral) {
            debug(node, ts.SyntaxKind[node.initializer.kind]);
        }
        const isStatic = _.some(node.modifiers, { kind: ts.SyntaxKind.StaticKeyword });
        if (isStatic && !isLiteral) {
            this.staticInitializers.push(node);
        }
        return super.visitPropertyDeclaration(node);
    }
    orderStaticInitializationMethodCalls() {
        const failures = this.getFailures();
        const otherFailures = [];
        const initializationMethodCalls = [];
        while (failures.length) {
            const failure = failures.pop();
            const target = failure.getFailure() === Rule.FILE_SHOULD_CALL_STATIC_INITIALIZATION_FUNCTION
                ? initializationMethodCalls
                : otherFailures;
            target.push(failure);
        }
        initializationMethodCalls.reverse();
        Array.prototype.push.apply(failures, otherFailures);
        Array.prototype.push.apply(failures, initializationMethodCalls);
    }
}
InitzializeStaticsAfterImportsWalker.METHOD_NAME = "__initialize_static_members";
