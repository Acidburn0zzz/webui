"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Lint = require("tslint");
const debug = require('debug')('tslint-no-bracket-notation-for-map');
debug('yo');
class Rule extends Lint.Rules.TypedRule {
    applyWithProgram(sourceFile, program) {
        return this.applyWithWalker(new NoBracketNotationOnMapsWalker(sourceFile, this.getOptions(), program));
    }
}
Rule.metadata = {
    ruleName: "no-bracket-notation-for-map",
    description: "Warn about the use of bracket notation on non-Arrays (e.g. `myMap['key']`).",
    hasFix: true,
    optionsDescription: "no options",
    options: {},
    type: "functionality",
    typescriptOnly: false,
};
Rule.REPLACE_BRACKET = "use `Map.get(key)` instead of []";
exports.Rule = Rule;
class NoBracketNotationOnMapsWalker extends Lint.ProgramAwareRuleWalker {
    constructor() {
        super(...arguments);
        this.identifierStack = [];
    }
    rememberIdentifier(node) {
        const entry = {
            identifier: node.name.getText(),
            type: node.type && node.type.getText() || 'any'
        };
        debug(entry, node);
        this.identifierStack.push(entry);
    }
    visitBlock(node) {
        const identifierStackLength = this.identifierStack.length;
        super.visitBlock(node);
        this.identifierStack = this.identifierStack.slice(0, identifierStackLength);
    }
    visitParameterDeclaration(node) {
        this.rememberIdentifier(node);
        super.visitParameterDeclaration(node);
    }
    visitVariableDeclaration(node) {
        this.rememberIdentifier(node);
        super.visitVariableDeclaration(node);
    }
    visitElementAccessExpression(node) {
        const tc = this.getTypeChecker();
        console.log(tc.getContextualType(node.expression));
        console.log(tc.getSymbolAtLocation(node.expression));
        const symbol = tc.getSymbolAtLocation(node.expression);
        const type = tc.getDeclaredTypeOfSymbol(symbol);
        console.log(tc.symbolToString(symbol));
        console.log(tc.typeToString(type));
        super.visitElementAccessExpression(node);
    }
}
